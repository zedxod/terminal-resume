<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>NullFrag — Command Prompt</title>

<style>
:root {
  --green:#33ff33;
  --bg:#000;
  --border:#2b2b2b;
  --titlebar:#111;
}
body{
  background:#111;
  font-family:Consolas,"Lucida Console",monospace;
  display:flex;
  justify-content:center;
  align-items:center;
  height:100vh;
  margin:0;
}
#cmd-window{
  width:900px;
  max-width:95%;
  background:var(--bg);
  border:2px solid var(--border);
  box-shadow:0 0 30px rgba(0,0,0,.8);
}
#title-bar{
  background:var(--titlebar);
  color:#ccc;
  padding:6px 10px;
  font-size:14px;
  display:flex;
  justify-content:space-between;
}
.window-buttons{display:flex;gap:6px;}
.btn{width:12px;height:12px;border-radius:50%;}
.close{background:#ff5f56;}
.minimize{background:#ffbd2e;}
.maximize{background:#27c93f;}

#terminal{
  color:var(--green);
  padding:15px;
  height:500px;
  overflow:hidden;
}
#output{white-space:pre;}
.prompt-line{display:flex;}
.prompt{margin-right:6px;}
input{
  background:transparent;
  border:none;
  outline:none;
  color:var(--green);
  font-family:inherit;
  font-size:1em;
  flex:1;
  caret-color:var(--green);
}
</style>
</head>

<body>
<div id="cmd-window">
  <div id="title-bar">
    <span>Command Prompt</span>
    <div class="window-buttons">
      <div class="btn close"></div>
      <div class="btn minimize"></div>
      <div class="btn maximize"></div>
    </div>
  </div>

  <div id="terminal">
    <div id="output"></div>
    <div class="prompt-line" id="prompt">
      <span class="prompt">C:\Users\NullFrag&gt;</span>
      <input id="cmd" disabled autofocus>
    </div>
  </div>
</div>

<script>
const output = document.getElementById("output");
const cmdInput = document.getElementById("cmd");
const promptEl = document.getElementById("prompt");
const terminal = document.getElementById("terminal");

let mode = "boot";
const history = [];
let historyIndex = -1;
let currentDir = ""; // "" = root, "resume" = inside resume folder

const promptRoot = "C:\\Users\\NullFrag>";
const promptResume = "C:\\Users\\NullFrag\\resume>";

// Fake filesystem contents
const filesInRoot = ["resume"];
const filesInResume = ["resume.txt"];

/* ---------------- COMMAND DATA ---------------- */
const data = {
  help: `
Available commands:
  help
  whoami
  resume
  skills
  projects
  contact
  snake
  ping <target>
  clear
`,
  whoami: `
Paramdeep Singh
Security Researcher / Software Engineer
`,
  resume: `
NAME     : Paramdeep Singh
ROLE     : Security Researcher / Software Engineer

SUMMARY:
Focused on Windows internals, low-level tooling,
credential access research, and stealthy C# utilities.
`,
  skills: `
Languages:
  C / C++
  C#
  Python
  PowerShell

Security:
  Windows Internals
  LSASS
  Malware Evasion
`,
  projects: `
• LSASS Dump Monitor (C#)
• In-memory Obfuscation Engine
• Native Win32 Dump Utility
`,
  contact: `
Email  : admin@nullfrag.online
GitHub : https://github.com/zedxod
`,

  // Hidden / easter egg commands
  ver:      "Microsoft Windows [Version 10.0.19045.4046 (NullFrag Edition)]",
  cd:       "Access denied. This is not that kind of shell... yet.", // fallback
  ls:       "dir/b",
  tasklist: "NullFrag    1337 Console                 1 K   Running",
  cat:      "Meow? (try typing: cat dog)",
  sudo:     "sudo: effective uid is still 0, nice try tho ;)"
};

const hiddenCommands = ["ver", "cd", "ls", "tasklist", "cat", "sudo"];

/* ---------------- UTIL ---------------- */
function print(line = "") {
  output.textContent += line + "\n";
  terminal.scrollTop = terminal.scrollHeight;
}

async function typeLine(text, delay = 14) {
  if (!text) { print(""); return; }
  let buf = "";
  for (const c of text) {
    buf += c;
    output.textContent = output.textContent.replace(/[^\n]*$/, buf);
    await new Promise(r => setTimeout(r, delay));
  }
  print("");
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

function updatePrompt() {
  const promptSpan = promptEl.querySelector(".prompt");
  promptSpan.textContent = currentDir ? promptResume : promptRoot;
}

/* ---------------- FAKE FILESYSTEM COMMANDS ---------------- */
function dirCommand() {
  const items = currentDir === "resume" ? filesInResume : filesInRoot;
  if (items.length === 0) {
    print(" File Not Found");
  } else {
    items.forEach(item => print(" " + item));
  }
}

function cdCommand(arg) {
  if (!arg || arg === ".") return;
  if (arg === "..") {
    currentDir = "";
    updatePrompt();
    return;
  }
  if (arg === "resume" && currentDir === "") {
    currentDir = "resume";
    updatePrompt();
    return;
  }
  print(`The system cannot find the path specified: ${arg}`);
}

async function catCommand(arg) {
  if (currentDir !== "resume") {
    print("The system cannot find the file specified.");
    return;
  }
  if (arg === "resume.txt") {
    await typeLine("");
    for (const line of data.resume.split("\n").filter(l => l.trim())) {
      await typeLine(line);
    }
  } else {
    print("The system cannot find the file specified.");
  }
}

function sleep(ms){
  return new Promise(resolve=>setTimeout(resolve,ms));
}

async function loadingDots(text, cycles=4, interval=400){
  const start=output.textContent.length;
  let dots=0;
  for(let i=0;i<cycles*2;i++){
    dots=(dots+1)%4;
    output.textContent=
      output.textContent.slice(0,start)+text+".".repeat(dots)+"\n";
    terminal.scrollTop=terminal.scrollHeight;
    await sleep(interval);
  }
}

/* ---------------- PING COMMAND (NEW) ---------------- */
async function pingCommand(target){
  print(`Pinging ${target} with 32 bytes of data:`);

  const times=[];

  for(let i=0;i<4;i++){
    const t=3+Math.floor(Math.random()*3); // 3–5 ms
    times.push(t);
    await sleep(700);
    print(`Reply from ${target}: bytes=32 time=${t}ms TTL=118`);
  }

  const min=Math.min(...times);
  const max=Math.max(...times);
  const avg=Math.round(times.reduce((a,b)=>a+b,0)/times.length);

  print("");
  print(`Ping statistics for ${target}:`);
  print(`    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),`);
  print(`Approximate round trip times in milli-seconds:`);
  print(`    Minimum = ${min}ms, Maximum = ${max}ms, Average = ${avg}ms`);
}

/* ---------------- BOOT ---------------- */
async function boot() {
  await typeLine("Microsoft Windows [Version 10.0.19045.4046]");
  await typeLine("(c) Microsoft Corporation. All rights reserved.");
  await typeLine("Initializing secure environment...");
  await loadingDots("Verifying hardware integrity", 3, 400);
  await loadingDots("Loading modules", 4, 350);         
  await loadingDots("Decrypting session keys", 4, 350); 
  await typeLine("Access granted.");
  await sleep(600);
  await typeLine("Welcome to Secret Lab");
  await typeLine("Type 'help' to continue.");
  mode = "shell";
  cmdInput.disabled = false;
  cmdInput.focus();
  updatePrompt();
}boot();

/* ---------------- SNAKE GAME (Centered popup + fixed head direction + bigger field) ---------------- */
function startSnake() {
  mode = "snake";
  cmdInput.disabled = true;
  promptEl.style.display = "none";
  output.textContent = "";

  const GAME_SPEED = 130;
  const SPEEDUP_EVERY = 10;
  const MIN_SPEED = 70;

  // Maximize space usage
  const charWidth = 8.8;
  const charHeight = 18;
  const cols = Math.floor(terminal.clientWidth / charWidth) - 4;
  const rows = Math.floor(terminal.clientHeight / charHeight) - 6;  // <-- BORDER LINES RESPONSIBLE FOR FRAME SIZE

  let snake = [{ x: Math.floor(cols / 2), y: Math.floor(rows / 2) }];
  let direction = { x: 1, y: 0 };
  let nextDirection = direction;
  let food = getRandomFoodPosition();
  let score = 0;
  let highScore = parseInt(localStorage.getItem("nf_snake_hs") || "0", 10);
  let gameRunning = true;
  let gamePaused = false;
  let gameInterval = null;

  // FIXED: Snake head now points CORRECTLY forward (rotated 180 where needed)
  const headChars = {
    '1,0':  '►',   // right
    '-1,0': '◄',   // left
    '0,-1': '▲',   // up
    '0,1':  '▼'    // down
  };

  function getRandomFoodPosition() {
    let pos;
    do {
      pos = {
        x: 1 + Math.floor(Math.random() * (cols - 2)),
        y: 1 + Math.floor(Math.random() * (rows - 2))
      };
    } while (snake.some(s => s.x === pos.x && s.y === pos.y));
    return pos;
  }

  function drawCenteredPopup(board, gameOver, gamePaused) {
    if (!gameOver && !gamePaused) return;

    const midRow = Math.floor(rows / 2);
    const status = gameOver ? "GAME OVER!" : "PAUSED";
    const instruction = gameOver ? "Press Q to quit" : "Press P/SPACE to resume";

    // Small popup box (5 lines high, centered)
    const boxWidth = Math.max(status.length, instruction.length) + 4;
    const boxLeft = Math.floor((cols - boxWidth) / 2);

    // Clear area
    for (let r = midRow - 2; r <= midRow + 2; r++) {
      if (r >= 0 && r < rows) {
        for (let c = boxLeft - 1; c < boxLeft + boxWidth + 1; c++) {
          if (c >= 0 && c < cols) board[r][c] = " ";
        }
      }
    }

    // Draw box
    if (midRow - 2 >= 0 && midRow - 2 < rows) {
      board[midRow - 2][boxLeft - 1] = "┌";
      for (let c = boxLeft; c < boxLeft + boxWidth; c++) {
        board[midRow - 2][c] = "─";
      }
      board[midRow - 2][boxLeft + boxWidth] = "┐";
    }

    // Top message
    const statusPad = Math.floor((boxWidth - status.length) / 2);
    for (let i = 0; i < status.length; i++) {
      board[midRow - 1][boxLeft + statusPad + i] = status[i];
    }

    // Instruction
    const instrPad = Math.floor((boxWidth - instruction.length) / 2);
    for (let i = 0; i < instruction.length; i++) {
      board[midRow][boxLeft + instrPad + i] = instruction[i];
    }

    // Bottom of box
    if (midRow + 1 >= 0 && midRow + 1 < rows) {
      board[midRow + 1][boxLeft - 1] = "└";
      for (let c = boxLeft; c < boxLeft + boxWidth; c++) {
        board[midRow + 1][c] = "─";
      }
      board[midRow + 1][boxLeft + boxWidth] = "┘";
    }
  }

  function drawBoard(gameOver = false) {
    let board = Array(rows).fill().map(() => Array(cols).fill(" "));

    // Snake body
    snake.slice(1).forEach(seg => {
      board[seg.y][seg.x] = "█";
    });

    // Snake head (directional, fixed)
    const headKey = `${direction.x},${direction.y}`;
    board[snake[0].y][snake[0].x] = headChars[headKey] || "█";

    // Food
    board[food.y][food.x] = "♦";

    // OVERLAY popup in center
    drawCenteredPopup(board, gameOver, gamePaused);

    // Frame borders (these lines create the border - adjust cols/rows above to resize)
    let text = "╔" + "═".repeat(cols) + "╗\n";  // <-- TOP BORDER

    board.forEach(row => {
      text += "║" + row.join("") + "║\n";      // <-- SIDE BORDERS
    });

    text += "╚" + "═".repeat(cols) + "╝\n";        // <-- BOTTOM BORDER

    // Score (always at bottom, compact)
    const scoreText = `Score: ${score.toString().padStart(4,'0')}  High: ${highScore.toString().padStart(4,'0')}`;
    const scorePad = Math.floor((cols + 2 - scoreText.length) / 2);  // +2 for borders
    text += "\n" + " ".repeat(scorePad) + scoreText;

    output.textContent = text;
  }

  function moveSnake() {
    if (!gameRunning || gamePaused) return;

    direction = nextDirection;

    const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };

    if (head.x < 0 || head.x >= cols || head.y < 0 || head.y >= rows ||
        snake.some((s, i) => i > 0 && s.x === head.x && s.y === head.y)) {
      gameRunning = false;
      drawBoard(true);
      return;
    }

    snake.unshift(head);

    if (head.x === food.x && head.y === food.y) {
      score++;
      if (score > highScore) {
        highScore = score;
        localStorage.setItem("nf_snake_hs", highScore);
      }
      food = getRandomFoodPosition();

      if (score % SPEEDUP_EVERY === 0 && gameInterval) {
        clearInterval(gameInterval);
        gameInterval = setInterval(moveSnake, Math.max(MIN_SPEED, GAME_SPEED - score * 4));
      }
    } else {
      snake.pop();
    }

    drawBoard();
  }

  function handleKey(e) {
    if (mode !== "snake") return;
    e.preventDefault();

    const k = e.key.toLowerCase();

    if ((k === "arrowup"    || k === "w") && direction.y !==  1) nextDirection = {x:0,  y:-1};
    if ((k === "arrowdown"  || k === "s") && direction.y !== -1) nextDirection = {x:0,  y: 1};
    if ((k === "arrowleft"  || k === "a") && direction.x !==  1) nextDirection = {x:-1, y: 0};
    if ((k === "arrowright" || k === "d") && direction.x !== -1) nextDirection = {x: 1, y: 0};

    if ((k === " " || k === "p") && gameRunning) {
      gamePaused = !gamePaused;
      drawBoard(gamePaused);
    }
    if (k === "q" && (!gameRunning || gamePaused)) exitSnake();
  }

  function exitSnake() {
    document.removeEventListener("keydown", handleKey);
    if (gameInterval) clearInterval(gameInterval);
    output.textContent = "";
    promptEl.style.display = "flex";
    cmdInput.disabled = false;
    cmdInput.focus();
    mode = "shell";
  }

  document.addEventListener("keydown", handleKey);
  drawBoard();
  gameInterval = setInterval(moveSnake, GAME_SPEED);
}

/* ---------------- MAIN SHELL ---------------- */
cmdInput.addEventListener("keydown", async e => {
  if (mode !== "shell") return;

  // History navigation
  if (e.key === "ArrowUp" && history.length) {
    historyIndex = historyIndex <= 0 ? history.length - 1 : historyIndex - 1;
    cmdInput.value = history[historyIndex];
    e.preventDefault();
  }
  if (e.key === "ArrowDown" && history.length) {
    historyIndex = historyIndex >= history.length - 1 ? -1 : historyIndex + 1;
    cmdInput.value = historyIndex === -1 ? "" : history[historyIndex];
    e.preventDefault();
  }

  if (e.key === "Enter") {
    const input = cmdInput.value.trim();
    if (input) {
      print(`C:\\Users\\NullFrag${currentDir ? '\\resume' : ''}> ${input}`);
      history.push(input);
      historyIndex = -1;
    }

    const [command, ...args] = input.split(/\s+/);
    const arg = args.join(" ");

    if (!command) {
      // just enter -> new line
    }
    else if (command === "snake") {
      startSnake();
    }
    else if (command === "clear") {
      output.textContent = "";
    }
    else if (command === "ping" && arg) {
      await pingCommand(arg);
    }
    else if (command === "show" && arg === "hidden") {
      await typeLine("Hidden / easter egg commands:");
      await sleep(300);
      for (const cmd of hiddenCommands) {
        await typeLine("  " + cmd);
        await sleep(80);
      }
      await sleep(400);
      await typeLine("Have fun discovering ;)");
    }
    // ────── Fake filesystem commands ──────
    else if (command === "dir" || command === "ls") {
      if (e.shiftKey) {
        await typeLine("dir is angry because you called him ls again...");
      } else {
        dirCommand();
      }
    }
    else if (command === "cd") {
      cdCommand(arg);
    }
    else if (command === "cat" && arg) {
      await catCommand(arg);
    }
    // ────── Normal & hidden commands ──────
    else if (data[command]) {
      for (const l of data[command].split("\n").filter(x => x.trim()))
        await typeLine(l);
    }
    else if (command === "whoami" && e.shiftKey) {
      await typeLine("root@nullfrag.local # whoami");
      await typeLine("guest");
    }
    else {
      print(`'${command}' is not recognized as an internal or external command,`);
      print("operable program or batch file.");
    }

    cmdInput.value = "";
  }
});
</script>
</body>
</html>
