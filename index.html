<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>NullFrag — Command Prompt</title>

<style>
:root {
  --green:#33ff33;
  --bg:#000;
  --border:#2b2b2b;
  --titlebar:#111;
}
body{
  background:#111;
  font-family:Consolas,"Lucida Console",monospace;
  display:flex;
  justify-content:center;
  align-items:center;
  height:100vh;
  margin:0;
  padding:0;
}
#cmd-window{
  width:900px;
  max-width:95%;
  background:var(--bg);
  border:2px solid var(--border);
  box-shadow:0 0 30px rgba(0,0,0,.8);
}
#title-bar{
  background:var(--titlebar);
  color:#ccc;
  padding:6px 10px;
  font-size:14px;
  display:flex;
  justify-content:space-between;
}
.window-buttons{display:flex;gap:6px;}
.btn{width:12px;height:12px;border-radius:50%;}
.close{background:#ff5f56;}
.minimize{background:#ffbd2e;}
.maximize{background:#27c93f;}

#terminal{
  color:var(--green);
  padding:15px;
  height:500px;
  overflow-y:auto;   
  overflow-x:hidden; 
}

#output{white-space:pre;}
.prompt-line{display:flex;}
.prompt{margin-right:6px;}
input{
  background:transparent;
  border:none;
  outline:none;
  color:var(--green);
  font-family:inherit;
  font-size:1em;
  flex:1;
  caret-color:var(--green);
}

/* Mobile Support Button */
#mobile-keyboard-btn {
  display:none;
  position:fixed;
  bottom:20px;
  right:20px;
  background:var(--green);
  color:#000;
  padding:12px 20px;
  border-radius:8px;
  cursor:pointer;
  font-weight:bold;
  box-shadow:0 4px 12px rgba(51,255,51,0.3);
  z-index:1000;
  user-select:none;
}
#mobile-keyboard-btn:active {
  transform:scale(0.95);
}

/* Mobile adjustments */
@media (max-width: 768px) {
  #cmd-window {
    width:100%;
    max-width:100%;
    height:100vh;
    border:none;
  }
  #terminal {
    height:calc(100vh - 40px);
    font-size:14px;
  }
  #mobile-keyboard-btn {
    display:block;
  }
}
</style>
</head>

<body>
<div id="cmd-window">
  <div id="title-bar">
    <span>Command Prompt</span>
    <div class="window-buttons">
      <div class="btn close"></div>
      <div class="btn minimize"></div>
      <div class="btn maximize"></div>
    </div>
  </div>

  <div id="terminal">
    <div id="output"></div>
    <div class="prompt-line" id="prompt">
      <span class="prompt">C:\Users\NullFrag&gt;</span>
      <input id="cmd" disabled autofocus>
    </div>
  </div>
</div>

<!-- Mobile keyboard button -->
<div id="mobile-keyboard-btn">⌨️ Type Command</div>

<script>
const output = document.getElementById("output");
const cmdInput = document.getElementById("cmd");
const promptEl = document.getElementById("prompt");
const terminal = document.getElementById("terminal");
const mobileBtn = document.getElementById("mobile-keyboard-btn");

let mode = "boot";
const history = [];
let historyIndex = -1;
let currentDir = "";
let skipTyping = false;

const promptRoot = "C:\\Users\\NullFrag>";
const promptResume = "C:\\Users\\NullFrag\\resume>";

// Fake filesystem contents
const filesInRoot = ["resume"];
const filesInResume = ["resume.txt"];

/* ---------------- COMMAND DATA ---------------- */
const data = {
  help: `
Available commands:
  help          - Show this help message
  whoami        - Display user information
  resume        - Show resume
  skills        - List technical skills
  projects      - Display projects
  contact       - Contact information
  snake         - Play snake game
  ping <target> - Ping a target
  clear         - Clear screen
`,
  whoami: `
Paramdeep Singh
Security Researcher / Software Engineer
`,
  resume: `
NAME     : Paramdeep Singh
ROLE     : Security Researcher / Software Engineer

SUMMARY:
Focused on Windows internals, low-level tooling,
credential access research, and stealthy C# utilities.
`,
  skills: `
Languages:
  C / C++
  C#
  Python
  PowerShell

Security:
  Windows Internals
  LSASS
  Malware Evasion
`,
  projects: `
• LSASS Dump Monitor (C#)
• In-memory Obfuscation Engine
• Native Win32 Dump Utility
`,
  contact: `
Email  : admin@nullfrag.online
GitHub : https://github.com/zedxod
`,

  // Hidden / easter egg commands
  ver:      "Microsoft Windows [Version 10.0.19045.4046 (NullFrag Edition)]",
  tasklist: "NullFrag    1337 Console                 1 K   Running",
  sudo:     "sudo: effective uid is still 0, nice try tho ;)"
};

const hiddenCommands = ["ver", "tasklist", "sudo", "traceroute", "date", "time", "matrix", "hack", "tree", "dir", "ls", "cd", "cat"];

/* ---------------- UTIL ---------------- */
function print(line = "") {
  output.textContent += line + "\n";
  terminal.scrollTop = terminal.scrollHeight;
}

// Blocking typing for boot sequence only
async function typeLine(text, delay = 14) {
  if (!text) { print(""); return; }
  if (skipTyping) {
    print(text);
    skipTyping = false;
    return;
  }
  let buf = "";
  for (const c of text) {
    buf += c;
    output.textContent = output.textContent.replace(/[^\n]*$/, buf);
    await new Promise(r => setTimeout(r, delay));
  }
  print("");
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

function updatePrompt() {
  if (isBooting) return;
  const promptSpan = promptEl.querySelector(".prompt");
  promptSpan.textContent = currentDir ? promptResume : promptRoot;
}

function disableTerminalScroll() {
  terminal.style.overflowY = "hidden";
}

function enableTerminalScroll() {
  terminal.style.overflowY = "auto";
}


/* ---------------- TAB COMPLETION ---------------- */
function getTabCompletion(input) {
  const commands = [...Object.keys(data), "snake", "clear", "ping", "traceroute", "date", "time", 
                    "matrix", "hack", "tree", "dir", "cd", "cat", "show", ...hiddenCommands];
  const matches = commands.filter(cmd => cmd.startsWith(input));
  return matches;
}

/* ---------------- COMMAND SUGGESTIONS ---------------- */
function findSimilarCommand(input) {
  const allCommands = [...Object.keys(data), "snake", "clear", "ping", "traceroute", "date", 
                       "time", "matrix", "hack", "tree", "dir", "cd", "cat"];
  
  const similar = allCommands.filter(cmd => {
    const minLen = Math.min(cmd.length, input.length);
    if (minLen < 3) return cmd.startsWith(input.substring(0, 2));
    return cmd.includes(input.substring(0, 3)) || input.includes(cmd.substring(0, 3));
  });
  
  return similar[0];
}

/* ---------------- FAKE FILESYSTEM COMMANDS ---------------- */
function dirCommand() {
  const items = currentDir === "resume" ? filesInResume : filesInRoot;
  if (items.length === 0) {
    print(" File Not Found");
  } else {
    items.forEach(item => print(" " + item));
  }
}

function cdCommand(arg) {
  if (!arg || arg === ".") return;
  if (arg === "..") {
    currentDir = "";
    updatePrompt();
    return;
  }
  if (arg === "resume" && currentDir === "") {
    currentDir = "resume";
    updatePrompt();
    return;
  }
  print(`The system cannot find the path specified: ${arg}`);
}

function catCommand(arg) {
  if (currentDir !== "resume") {
    print("The system cannot find the file specified.");
    return;
  }
  if (arg === "resume.txt") {
    print("");
    const lines = data.resume.split("\n").filter(l => l.trim());
    lines.forEach(line => print(line));
  } else {
    print("The system cannot find the file specified.");
  }
}

async function loadingDots(text, cycles=4, interval=400){
  const start=output.textContent.length;
  let dots=0;
  for(let i=0;i<cycles*2;i++){
    dots=(dots+1)%4;
    output.textContent=
      output.textContent.slice(0,start)+text+".".repeat(dots)+"\n";
    terminal.scrollTop=terminal.scrollHeight;
    await sleep(interval);
  }
}

/* ---------------- PING COMMAND ---------------- */
async function pingCommand(target){
  print(`Pinging ${target} with 32 bytes of data:`);

  const times=[];

  for(let i=0;i<4;i++){
    const t=3+Math.floor(Math.random()*3);
    times.push(t);
    await sleep(700);
    print(`Reply from ${target}: bytes=32 time=${t}ms TTL=118`);
  }

  const min=Math.min(...times);
  const max=Math.max(...times);
  const avg=Math.round(times.reduce((a,b)=>a+b,0)/times.length);

  print("");
  print(`Ping statistics for ${target}:`);
  print(`    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),`);
  print(`Approximate round trip times in milli-seconds:`);
  print(`    Minimum = ${min}ms, Maximum = ${max}ms, Average = ${avg}ms`);
}

/* ---------------- TRACEROUTE COMMAND ---------------- */
async function tracerouteCommand(target) {
  print(`Tracing route to ${target} over a maximum of 10 hops:\n`);
  
  const hops = [
    "192.168.1.1",
    "10.0.0.1", 
    "172.16.254.1",
    "203.0.113.1",
    target
  ];
  
  for (let i = 0; i < hops.length; i++) {
    await sleep(600);
    const ms1 = 1 + Math.floor(Math.random() * 5);
    const ms2 = ms1 + Math.floor(Math.random() * 3);
    const ms3 = ms2 + Math.floor(Math.random() * 2);
    print(`  ${(i + 1).toString().padStart(2)}    ${ms1} ms    ${ms2} ms    ${ms3} ms    ${hops[i]}`);
  }
  print("\nTrace complete.");
}

/* ---------------- DATE/TIME COMMAND ---------------- */
function dateTimeCommand() {
  const now = new Date();
  print(`The current date is: ${now.toDateString()}`);
  print(`The current time is: ${now.toLocaleTimeString()}`);
}

/* ---------------- ENHANCED EASTER EGGS ---------------- */
async function matrixEffect() {
  const chars = "ﾊﾐﾋｰｳｼﾅﾓﾆｻﾜﾂｵﾘｱﾎﾃﾏｹﾒｴｶｷﾑﾕﾗｾﾈｽﾀﾇﾍ01";
  print("\n[ENTERING THE MATRIX...]\n");
  await sleep(500);
  
  for (let i = 0; i < 12; i++) {
    let line = "";
    for (let j = 0; j < 70; j++) {
      line += chars[Math.floor(Math.random() * chars.length)];
    }
    await typeLine(line, 1);
  }
  
  await sleep(800);
  print("\n[CONNECTION TERMINATED]\n");
}

async function hackEffect() {
  print("\n[INITIALIZING HACK SEQUENCE...]");
  await sleep(500);
  await loadingDots("Bypassing firewall", 3, 300);
  await loadingDots("Cracking encryption", 3, 300);
  await loadingDots("Accessing mainframe", 3, 300);
  print("\n[ACCESS GRANTED]");
  print("Just kidding! This is just a portfolio site ;)");
}

async function treeCommand() {
  print("\nC:\\USERS\\NULLFRAG");
  await sleep(200);
  print("│");
  print("├───resume");
  await sleep(100);
  print("│   └───resume.txt");
  await sleep(100);
  print("│");
  print("├───projects");
  await sleep(100);
  print("│   ├───lsass-monitor.exe");
  print("│   ├───obfuscator.dll");
  print("│   └───win32-dump.exe");
  await sleep(100);
  print("│");
  print("└───skills");
  await sleep(100);
  print("    ├───languages.txt");
  print("    └───security.txt");
  print("");
}

let isBooting = true;


/* ---------------- BOOT ---------------- */
async function boot() {
  await typeLine("Microsoft Windows [Version 10.0.19045.4046]");
  await typeLine("(c) Microsoft Corporation. All rights reserved.");
  await typeLine("Initializing secure environment...");
  await loadingDots("Verifying hardware integrity", 3, 400);
  await loadingDots("Loading modules", 4, 350);         
  await loadingDots("Decrypting session keys", 4, 350); 
  await typeLine("Access granted.");
  await sleep(600);
  await typeLine("Welcome to Secret Lab");
  await typeLine("Type 'help' to continue.");
  misBooting = false;
  mode = "shell";
  cmdInput.disabled = false;
  updatePrompt();
  cmdInput.focus();

}

/* ---------------- SNAKE GAME ---------------- */
function startSnake() {
  mode = "snake";
  disableTerminalScroll();
  cmdInput.disabled = true;
  promptEl.style.display = "none";
  output.textContent = "";

  const GAME_SPEED = 130;
  const SPEEDUP_EVERY = 10;
  const MIN_SPEED = 70;

  const charWidth = 8.8;
  const charHeight = 18;
  const cols = Math.floor(terminal.clientWidth / charWidth) - 4;
  const rows = Math.floor(terminal.clientHeight / charHeight) - 6;

  let snake = [{ x: Math.floor(cols / 2), y: Math.floor(rows / 2) }];
  let direction = { x: 1, y: 0 };
  let nextDirection = direction;
  let food = getRandomFoodPosition();
  let score = 0;
  let highScore = parseInt(localStorage.getItem("nf_snake_hs") || "0", 10);
  let gameRunning = true;
  let gamePaused = false;
  let gameInterval = null;

  const headChars = {
    '1,0':  '►',
    '-1,0': '◄',
    '0,-1': '▲',
    '0,1':  '▼'
  };

  function getRandomFoodPosition() {
    let pos;
    do {
      pos = {
        x: 1 + Math.floor(Math.random() * (cols - 2)),
        y: 1 + Math.floor(Math.random() * (rows - 2))
      };
    } while (snake.some(s => s.x === pos.x && s.y === pos.y));
    return pos;
  }

  function drawCenteredPopup(board, gameOver, gamePaused) {
    if (!gameOver && !gamePaused) return;

    const midRow = Math.floor(rows / 2);
    const status = gameOver ? "GAME OVER!" : "PAUSED";
    const instruction = gameOver ? "Press Q to quit" : "Press P/SPACE to resume";

    const boxWidth = Math.max(status.length, instruction.length) + 4;
    const boxLeft = Math.floor((cols - boxWidth) / 2);

    for (let r = midRow - 2; r <= midRow + 2; r++) {
      if (r >= 0 && r < rows) {
        for (let c = boxLeft - 1; c < boxLeft + boxWidth + 1; c++) {
          if (c >= 0 && c < cols) board[r][c] = " ";
        }
      }
    }

    if (midRow - 2 >= 0 && midRow - 2 < rows) {
      board[midRow - 2][boxLeft - 1] = "┌";
      for (let c = boxLeft; c < boxLeft + boxWidth; c++) {
        board[midRow - 2][c] = "─";
      }
      board[midRow - 2][boxLeft + boxWidth] = "┐";
    }

    const statusPad = Math.floor((boxWidth - status.length) / 2);
    for (let i = 0; i < status.length; i++) {
      board[midRow - 1][boxLeft + statusPad + i] = status[i];
    }

    const instrPad = Math.floor((boxWidth - instruction.length) / 2);
    for (let i = 0; i < instruction.length; i++) {
      board[midRow][boxLeft + instrPad + i] = instruction[i];
    }

    if (midRow + 1 >= 0 && midRow + 1 < rows) {
      board[midRow + 1][boxLeft - 1] = "└";
      for (let c = boxLeft; c < boxLeft + boxWidth; c++) {
        board[midRow + 1][c] = "─";
      }
      board[midRow + 1][boxLeft + boxWidth] = "┘";
    }
  }

  function drawBoard(gameOver = false) {
    let board = Array(rows).fill().map(() => Array(cols).fill(" "));

    snake.slice(1).forEach(seg => {
      board[seg.y][seg.x] = "█";
    });

    const headKey = `${direction.x},${direction.y}`;
    board[snake[0].y][snake[0].x] = headChars[headKey] || "█";

    board[food.y][food.x] = "♦";

    drawCenteredPopup(board, gameOver, gamePaused);

    let text = "╔" + "═".repeat(cols) + "╗\n";

    board.forEach(row => {
      text += "║" + row.join("") + "║\n";
    });

    text += "╚" + "═".repeat(cols) + "╝\n";

    const scoreText = `Score: ${score.toString().padStart(4,'0')}  High: ${highScore.toString().padStart(4,'0')}`;
    const scorePad = Math.floor((cols + 2 - scoreText.length) / 2);
    text += "\n" + " ".repeat(scorePad) + scoreText;

    output.textContent = text;
  }

  function moveSnake() {
    if (!gameRunning || gamePaused) return;

    direction = nextDirection;

    const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };

    if (head.x < 0 || head.x >= cols || head.y < 0 || head.y >= rows ||
        snake.some((s, i) => i > 0 && s.x === head.x && s.y === head.y)) {
      gameRunning = false;
      drawBoard(true);
      return;
    }

    snake.unshift(head);

    if (head.x === food.x && head.y === food.y) {
      score++;
      if (score > highScore) {
        highScore = score;
        localStorage.setItem("nf_snake_hs", highScore);
      }
      food = getRandomFoodPosition();

      if (score % SPEEDUP_EVERY === 0 && gameInterval) {
        clearInterval(gameInterval);
        gameInterval = setInterval(moveSnake, Math.max(MIN_SPEED, GAME_SPEED - score * 4));
      }
    } else {
      snake.pop();
    }

    drawBoard();
  }

  function handleKey(e) {
    if (mode !== "snake") return;
    e.preventDefault();

    const k = e.key.toLowerCase();

    if ((k === "arrowup"    || k === "w") && direction.y !==  1) nextDirection = {x:0,  y:-1};
    if ((k === "arrowdown"  || k === "s") && direction.y !== -1) nextDirection = {x:0,  y: 1};
    if ((k === "arrowleft"  || k === "a") && direction.x !==  1) nextDirection = {x:-1, y: 0};
    if ((k === "arrowright" || k === "d") && direction.x !== -1) nextDirection = {x: 1, y: 0};

    if ((k === " " || k === "p") && gameRunning) {
      gamePaused = !gamePaused;
      drawBoard(gamePaused);
    }
    if (k === "q" && (!gameRunning || gamePaused)) exitSnake();
  }

  function exitSnake() {
    document.removeEventListener("keydown", handleKey);
    if (gameInterval) clearInterval(gameInterval);
    enableTerminalScroll();
    output.textContent = "";
    promptEl.style.display = "flex";
    cmdInput.disabled = false;
    cmdInput.focus();
    mode = "shell";
  }

  document.addEventListener("keydown", handleKey);
  drawBoard();
  gameInterval = setInterval(moveSnake, GAME_SPEED);
}

/* ---------------- GLOBAL KEY HANDLERS ---------------- */
document.addEventListener("keydown", e => {
  // CTRL+C to skip typing animation
  if (e.ctrlKey && e.key === "c" && mode === "shell") {
    skipTyping = true;
  }
});

/* ---------------- MOBILE SUPPORT ---------------- */
mobileBtn.addEventListener('click', () => {
  cmdInput.focus();
  cmdInput.click();
});

cmdInput.addEventListener('focus', () => {
  if (window.innerWidth <= 768) {
    mobileBtn.style.opacity = '0.3';
  }
});

cmdInput.addEventListener('blur', () => {
  if (window.innerWidth <= 768) {
    mobileBtn.style.opacity = '1';
  }
});

/* ---------------- MAIN SHELL ---------------- */
cmdInput.addEventListener("keydown", async e => {
  if (mode !== "shell") return;

  // TAB COMPLETION
  if (e.key === "Tab") {
    e.preventDefault();
    const input = cmdInput.value.trim();
    const matches = getTabCompletion(input);
    
    if (matches.length === 1) {
      cmdInput.value = matches[0];
    } else if (matches.length > 1) {
      print(`\nPossible commands: ${matches.join(", ")}`);
      print(`C:\\Users\\NullFrag${currentDir ? '\\resume' : ''}> ${input}`);
    }
    return;
  }

  // History navigation
  if (e.key === "ArrowUp" && history.length) {
    historyIndex = historyIndex <= 0 ? history.length - 1 : historyIndex - 1;
    cmdInput.value = history[historyIndex];
    e.preventDefault();
  }
  if (e.key === "ArrowDown" && history.length) {
    historyIndex = historyIndex >= history.length - 1 ? -1 : historyIndex + 1;
    cmdInput.value = historyIndex === -1 ? "" : history[historyIndex];
    e.preventDefault();
  }

  if (e.key === "Enter") {
    const input = cmdInput.value.trim();
    if (input) {
      print(`C:\\Users\\NullFrag${currentDir ? '\\resume' : ''}> ${input}`);
      history.push(input);
      historyIndex = -1;
    }

    const [command, ...args] = input.split(/\s+/);
    const arg = args.join(" ");

    if (!command) {
      // just enter -> new line
    }
    else if (command === "snake") {
      startSnake();
    }
    else if (command === "clear") {
      output.textContent = "";
    }
    else if (command === "ping" && arg) {
      await pingCommand(arg);
    }
    else if (command === "traceroute" && arg) {
      await tracerouteCommand(arg);
    }
    else if (command === "date" || command === "time") {
      dateTimeCommand();
    }
    else if (command === "matrix") {
      await matrixEffect();
    }
    else if (command === "hack") {
      await hackEffect();
    }
    else if (command === "tree") {
      await treeCommand();
    }
    else if (command === "show" && arg === "hidden") {
      print("Hidden / Easter Egg Commands:");
      print("");
      print("  Network & System:");
      print("    traceroute <target> - Trace route to target");
      print("    date                - Show current date and time");
      print("    time                - Show current time");
      print("    ver                 - Show Windows version");
      print("    tasklist            - Show running processes");
      print("");
      print("  Fun Effects:");
      print("    matrix              - Enter the matrix");
      print("    hack                - Initialize hack sequence");
      print("    tree                - Show directory tree");
      print("    sudo                - Try sudo access");
      print("");
      print("  File System:");
      print("    dir / ls            - List directory contents");
      print("    cd <dir>            - Change directory");
      print("    cat <file>          - Display file contents");
    }
    // ────── Fake filesystem commands ──────
    else if (command === "dir" || command === "ls") {
      if (e.shiftKey) {
        print("dir is angry because you called him ls again...");
      } else {
        dirCommand();
      }
    }
    else if (command === "cd") {
      cdCommand(arg);
    }
    else if (command === "cat" && arg) {
      catCommand(arg);
    }
    // ────── Normal & hidden commands ──────
    else if (data[command]) {
      const lines = data[command].split("\n").filter(x => x.trim());
      lines.forEach(line => print(line));
    }
    else if (command === "whoami" && e.shiftKey) {
      print("root@nullfrag.local # whoami");
      print("guest");
    }
    else {
      print(`'${command}' is not recognized as an internal or external command,`);
      print("operable program or batch file.");
      
      // COMMAND SUGGESTIONS
      const suggestion = findSimilarCommand(command);
      if (suggestion) {
        print(`\nDid you mean: ${suggestion}?`);
      }
    }

    cmdInput.value = "";
  }
});
// Start boot sequence
boot();
</script>
</body>
</html>
